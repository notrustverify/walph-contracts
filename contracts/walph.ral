Contract Walph(
    poolSize: U256,
    poolOwner: Address,
    poolFees: U256,
    ticketPrice: U256,
    attendeesStackContractKey: ByteVec,
    mut open: Bool,
    mut balance: U256,
    mut feesBalance: U256,
    mut numAttendees: U256,
    mut lastWinner: Address
){
    

    event TicketBought(from: Address, amount: U256)
    event PoolOpen()
    event PoolClose()
    event Destroy(from: Address)
    event NewMinTokenAmountToHold(newAmount: U256)
    event Winner(address: Address)

    enum ErrorCodes {
        PoolFull = 0
        PoolAlreadyClose = 1
        PoolAlreadyOpen = 2
        PoolClosed = 3
        InvalidCaller = 4
        NotEnoughToken = 5
        PoolNotFull = 6
        InvalidAmount = 7
    }


    fn random() -> (U256){
        assert!(numAttendees > 0, ErrorCodes.PoolNotFull)
        let seed = u256From32Byte!(blake2b!(toByteVec!(blockTarget!()) ++ toByteVec!(blockTimeStamp!())))
        emit Debug(`rnd is ${seed}`)
        return addModN!(0,seed, numAttendees)
    }

    @using(preapprovedAssets = true, assetsInContract = false, updateFields = true, checkExternalCaller = false)
    fn distributePrize(lastAttendee: Address, amount: U256) -> (){
         checkCaller!(callerAddress!() == selfAddress!(), ErrorCodes.InvalidCaller)
         assert!(balance + amount >= poolSize, ErrorCodes.PoolNotFull)

        lastWinner = attendees[random()]
        

        let poolOwnerAmount = balance * poolFees/100
        let winnerAmount = balance - poolOwnerAmount
        balance = 0
        numAttendees = 0

        //transferTokenFromSelf!(poolOwner, ALPH, poolOwnerAmount)
        transferTokenFromSelf!(lastWinner, ALPH, winnerAmount)

        // the last attendee will be the one with the rest of ALPH to sent to the winner, it will be the one who send it in addition of the rest of the pool
        transferToken!(lastAttendee, lastWinner, ALPH, amount)

        emit Winner(lastWinner)

     }


    pub fn getPoolState() -> (Bool) {
        return open
    }

    pub fn getPoolSize() -> (U256) {
        return poolSize
    }

    pub fn getBalance() -> (U256){
        return balance
    }

    pub fn getTicketPrice() -> (U256){
        return ticketPrice
    }
    
    @using(preapprovedAssets = false, assetsInContract = true, updateFields = true, checkExternalCaller = false)
    pub fn withdraw() -> () {
        checkCaller!(callerAddress!() == poolOwner, ErrorCodes.InvalidCaller)
        assert!(feesBalance > 0, ErrorCodes.PoolNotFull)

        // (poolFees/100) * 10**18 == poolFees * 10**16
        transferTokenFromSelf!(poolOwner, ALPH, feesBalance - 2* dustAmount!()) // to not hit LowerThanContractMinimalBalance
        feesBalance = 0

    }


    pub fn initAttendeesStack() -> (){
        checkCaller!(callerAddress!() == poolOwner, ErrorCodes.InvalidCaller)

        setAttendeesStack(callerAddress!(),selfContractId!() , poolOwner, callerAddress!(), 1, attendees, 0)
    }

    // Note for later: this could work but since the array have to initialized and then passed to the function it make no sense to use a subcontract. What I'm looking here is to be able to init without having to pass an array and then just use pop() and push() function
    @using(preapprovedAssets = true, checkExternalCaller = false, assetsInContract = true )
    fn setAttendeesStack(caller: Address, key: U256,
        owner: Address,
        zeroAddress: Address,
        stackSize: U256,
        attendees: [Address;100],
        index: U256 ) -> (){
        assert!(attendeesKey > 0, ErrorCodes.AttendeesAlreadyDeployed)
        checkCaller!(caller == poolOwner, ErrorCodes.InvalidCaller)
        let path = u256To8Bytes!(key) // key can be anything, just have to a ByteVec type

        let (encodedImmFields, encodedMutFields) = AttendeesStack.encodeFields!(
            owner,
            zeroAddress,
            stackSize,
            attendees,
            index)

        // Contract `AttendeesStack` has multiple fields
        // Create a sub contract from the given key and value.
        // The sub contract id is `blake2b(blake2b(selfContractId!() ++ path))`.
        // It will fail if the sub contract already exists.
        let contractId = copyCreateSubContract!(
            path,
            attendeesStackTemplateId,
            encodedImmFields,
            encodedMutFields
        )
        
        // maybe it's not a good to store it, will see later
        attendeesKey = path
        emit SubContractCreated(key, contractId)
    }

    @using(preapprovedAssets = true, assetsInContract = true, updateFields = true, checkExternalCaller = false)
    pub fn buyTicket(amount: U256) -> (){
        let caller = callerAddress!()
        assert!(balance + amount <= poolSize, ErrorCodes.PoolFull)
        assert!(open, ErrorCodes.PoolClosed)
        assert!(addModN!(amount,0 , 10 ** 18) == 0, ErrorCodes.InvalidAmount)
        assert!(amount >= ticketPrice, ErrorCodes.InvalidAmount)
                
        let numberTicketsBought = amount / ticketPrice
        let mut numberPlaceCounter = 0

        let path = u256To8Bytes!(key)
        // Get the sub contract id by the `subContractId!` built-in function
        let attendeesStack =  subContractId!(path)

        while(numberPlaceCounter < numberTicketsBought){
            attendeesStack.push(caller)
            numAttendees = numAttendees + 1
            numberPlaceCounter = numberPlaceCounter + 1
        }

        emit TicketBought(caller, amount)

        // used to check if the amount added will close the pool
        let balanceCheck = balance + amount
        feesBalance = feesBalance + amount * poolFees/100
        // last person to complete the pool close it and start the draw
        if (balanceCheck >= poolSize){
            assert!(balanceCheck >= poolSize, ErrorCodes.PoolNotFull)
            
            // check if the number of attendees is full
            assert!(numAttendees == poolSize / ticketPrice, ErrorCodes.PoolNotFull)
            

            distributePrize{selfAddress!() -> ALPH: balance; caller -> ALPH: amount}(caller, amount)
       } else {
            balance = balance + amount
            transferTokenToSelf!(caller, ALPH, amount)
       }
    }

    @using(updateFields = true, checkExternalCaller = true)
    pub fn closePool() -> (){
        assert!(open, ErrorCodes.PoolAlreadyClose)
        checkCaller!(callerAddress!() == poolOwner, ErrorCodes.InvalidCaller)

        open = false

        emit PoolClose()
    }

    @using(updateFields = true, checkExternalCaller = true)
    pub fn openPool() -> (){
        assert!(!open, ErrorCodes.PoolAlreadyOpen)
        checkCaller!(callerAddress!() == poolOwner, ErrorCodes.InvalidCaller)

        open = true

        emit PoolOpen()
    }

    @using(assetsInContract = true, updateFields = false, checkExternalCaller = true)
    pub fn destroyPool() -> () {
        checkCaller!(callerAddress!() == poolOwner, ErrorCodes.InvalidCaller)

        destroySelf!(poolOwner)

        emit Destroy(poolOwner)
    }

    @using(assetsInContract = false, updateFields = true, checkExternalCaller = true)
    pub fn changeMinAmountToHold(newAmount: U256) -> () {
        checkCaller!(callerAddress!() == poolOwner, ErrorCodes.InvalidCaller)

        minTokenAmountToHold = newAmount

        emit NewMinTokenAmountToHold(newAmount)
    }


}
