Contract WalphStack(
    owner: Address,
    stackSize: U256,
    mut contractOwnerSet: Bool,
    mut contractAddressOwner: Address,
    mut attendees: [Address;10],
    mut index: U256
){

    event AddressPushed(address: Address)
    event AddressPopped(address: Address)

    enum ErrorCodes {
        StackEmpty = 0
        StackFull = 1
        InvalidCaller = 2
        OutOfBound = 3
        ContractOwnerNotSet = 4
    }

    pub fn getIndex() -> (U256){
        return index
    }

    pub fn getElementByIndex(indexToGet: U256) -> (Address){
        assert!(indexToGet < stackSize, ErrorCodes.OutOfBound)

        return attendees[indexToGet]
    }

    pub fn getStackSize() -> (U256){
        return stackSize
    }

    @using(updateFields = true)
    pub fn setOwner(walphContractAddress: Address) -> (){
        checkCaller!(callerAddress!() == owner, ErrorCodes.InvalidCaller)
        contractAddressOwner =  walphContractAddress
        contractOwnerSet = true
    }

    @using(updateFields = true)
    pub fn pop() -> (Address) {
        checkCaller!(callerAddress!() == owner, ErrorCodes.InvalidCaller)

        assert!(index > 0, ErrorCodes.StackEmpty)
        assert!(contractOwnerSet, ErrorCodes.ContractOwnerNotSet)

        let addressPopped = attendees[index]
        index = index - 1

        emit AddressPopped(addressPopped)

        return addressPopped
    }

    @using(updateFields = true)
    pub fn push(address: Address) -> (){
        checkCaller!(callerAddress!() == owner, ErrorCodes.InvalidCaller)

        assert!(index < stackSize, ErrorCodes.StackFull)
        assert!(contractOwnerSet, ErrorCodes.ContractOwnerNotSet)
        
        attendees[index] = address
        index = index + 1

        emit AddressPushed(address)
    }

    @using(updateFields = true)
    pub fn resetIndex() -> (){
        checkCaller!(callerAddress!() == owner, ErrorCodes.InvalidCaller)

        assert!(contractOwnerSet, ErrorCodes.ContractOwnerNotSet)

        index = 0

    }

}